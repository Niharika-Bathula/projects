# -*- coding: utf-8 -*-
"""play_store.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U03JXjOQBSW-WpTknZykd9kTfCoSmB4q

**App** - It tells us about the name of the application.

**Category** - It tells us about the category to which an application belongs.

**Rating**- It tells us about the ratings given by the users for a specific application.

**Reviews** - It tells us about the total number of users who have given a review for the application.

**Size**- It tells us about the size being occupied the application on the mobile phone.

**Installs** - It tells us about the total number of installs/downloads for an application.
**Type** - It tells us whether the application is free or a paid one.

**Price**- It tells us about the price of the application.

**Content_Rating**- It tells us about the target audience for the application.

**Genres** - It tells us about the various other categories to which an application can belong.

**Last_Updated** - It tells us about the when the application was updated.

**Current_Ver** - It tells us about the current version of the application.

**Android_Ver** - It tells us about the android version which can support the application on its platform
"""

# Commented out IPython magic to ensure Python compatibility.
#import library
import numpy as np               #linear algebra
import pandas as pd
import matplotlib.pyplot as plt #visualization tool
# %matplotlib inline
import seaborn as sns            #visualization tool


import warnings
warnings.filterwarnings('ignore')

"""### **Google Drive Mounted**

"""

#from google.colab import drive
#drive.mount('/content/drive')

#Loading the Dataset, So that we can read our dataset further.
dataset1= pd.read_csv('/content/Play Store Data.csv')
dataset2= pd.read_csv('/content/User Reviews.csv')

# now creating a duplicated copy of data set so that futher manipulation in dataset will not affect origional dataset and we can use for refrence further.
df_1=dataset1.copy()
df_2=dataset2.copy()

"""# **Data Inspection**"""

#Top 5 Row of play store Dataset
df_1.head()

#Top 5 Row of user dataset
df_2.head()

# Bottom 5 row of play store Dataset
df_1.tail()

# Bottom 5 row of user dataset
df_2.tail()

# random 5 rows of the playstore dataset.
df_1.sample(4)

# random 5 rows of the User review dataset.
df_2.sample(4)

# Checking column of playstore dataset
df_1.columns.to_list()

# Checking column of user review dataset
df_2.columns.to_list()

# Checking Row & Columns in Dataset.
print('Row & Columns of Play Store Dataset is:',df_1.shape)
print('\n')
print('Row & Columns of User Dataset is:',df_2.shape)

"""## Dataset Information"""

# Dataset info for playstore dataset.
df_1.info()

"""Major null value present in Rating Column & only one float column and others are Object columns."""

# Dataset info for user review dataset.
df_2.info()

"""Major null present in Translated_Review, Sentiment, Sentiment_Polarity, Sentiment_Subjectivity.

Sentiment_polarity & sentiment_subjectivity are float columns and other are Object column

## Dataset Cleaning
"""

# we are checking here some wrong entries like #,@,%,?,+,& in string or in integer type coloumn that we are unable to find during null value detection.
for num,col in enumerate(df_1.columns,1):
    print('\n')
    print(num,')\n','{} : {}'.format(col,df_1[col].unique().tolist()))

# Finding Null Values and arrange in decending orders

null_val = df_1.isnull().sum().sort_values(ascending=False).head().reset_index().rename(columns={'index':'column',0:'count'})
null_val

"""Maximum Null Value found in Rating Column"""

null_val = df_2.isnull().sum().sort_values(ascending=False).head().reset_index().rename(columns={'index':'column',0:'count'})
null_val

""" comment req"""

# Removing Null Value Row.
df_1.dropna(subset=["Type","Content Rating", "Current Ver", "Android Ver"], inplace= True)

df_1.isnull().sum()

df_1.boxplot()

"""From Box plot we can observe that 4.3 median of Rating Majority Consumer gave 4.3 Rating"""

#Fill Null Value With Median of Rating Column.
medn_rating=df_1['Rating'].median()
df_1['Rating']=df_1['Rating'].fillna(df_1['Rating'].transform(lambda x:medn_rating))
df_1.isnull().sum()

# Null Value in User Review
df_2.isnull().sum()

df_2=df_2.dropna()

# duplicate values in play store dataset.
df_1.duplicated().sum()

# Droping duplicates value
df_1= df_1.drop_duplicates()

# Checking Duplicates Value After Droping.
df_1.duplicated().sum()

df_2.duplicated().sum()

df_2=df_2.drop_duplicates()

"""All Duplicates values are Removed"""

# Checking row & Columns of Play store Dataset after removing dataset
print('Row & Columns of Play Store Dataset is:',df_1.shape)
print('Row & Columns of User Dataset is:',df_2.shape)

"""###manipulating Play store Columns"""

df_1['Installs'].unique()

df_1['Installs']=df_1['Installs'].apply(lambda x:str(x).replace('+','')if '+' in str(x) else str(x))
df_1['Installs']=df_1['Installs'].apply(lambda x:str(x).replace(',','')if ','in str(x)else str(x))
df_1['Installs']=df_1['Installs'].apply(lambda x:float(x))

df_1['Installs'].unique()

# We will change If required
df_1['Type'].unique()

df_1['Price'].unique()

df_1['Price']=df_1['Price'].apply((lambda x:str(x).replace('$','') if'$'in str(x) else str(x)))
df_1['Price']=df_1['Price'].apply((lambda x:float(x)))
df_1['Price'].unique()

df_1['Size'].unique()

df_1['Category'].unique()

df_1['Last Updated'].value_counts().sort_values(ascending=False)

df_1['Android Ver'].value_counts().sort_values(ascending=False)

df_1['Android Ver'] = df_1['Android Ver'].str.replace(' and up', '')

df_1['Android Ver']=df_1['Android Ver'].replace('Varies with device','4.1')

df_1['Android Ver'].unique()

df_1['Current Ver'].value_counts().sort_values(ascending=False)

df_1['Current Ver']=df_1['Current Ver'].replace('Varies with device',1.0)

df_1['Last Updated'].unique()

"""### Data Cleaning Of User Review dataset"""

df_2.info()

df_2.sample(5)

"""### Data Visulization(max14)insight

1) **Number of Installation in paid and Free apps**
"""

# Total number of apps.
T_Apps_count=df_1['App'].count()
T_Apps_count

# Number of free and Paid apps
N_apps_Count=df_1.groupby('Type')['App'].count()
N_apps_Count

#Total number of Installation in paid & Free apps
T_num_apps=df_1.groupby('Type')['Installs'].sum().reset_index()
T_num_apps

#convert exponenials to integer number
T_num_apps['Installs'] =T_num_apps['Installs'].astype('int64')
T_num_apps

# Visulization

fig=plt.figure(figsize=(14,4))
plt.subplot(1, 2, 1)

# percentage of free and Paid apps
N_apps_Count.plot(kind='pie', colors=['hotpink', 'goldenrod'], autopct='%1.1f%%',startangle =180, textprops={'fontsize': 14},explode = (0, 0.2))
plt.title('Total Percentage of Free and Paid Apps',fontsize=10,fontweight="bold")
plt.ylabel('')
plt.legend()

#Total number of Installation in paid & Free apps
plt.subplot(1, 2, 2)
sns.barplot(x='Type',y='Installs', data=T_num_apps, palette="Set2")
plt.title('Total number of apps',fontsize=10,fontweight="bold")
plt.ylabel('Count')


plt.show()

"""**Observation**

*   Total number of apps are 10346
*   Free app count :-9584, Paid app Count:-762

*   Out of Total apps in google play according to dataset 92.6% Apss are free &7.4% Apps are Paid
*   Total number of Installation in Free apps is more compare to Paid Apps In bar graph it is not visible because number of Paid app is less.

Q2) **Total Installation According to Content Rating Wise  & Total Apps according to Content Rating Count**.
"""

# Total Apps according to Content Rating Count.
content_rating_counts = df_1['Content Rating'].value_counts()
content_rating_counts

#Total Installation According to Content Rating Wise.

content_apps_intallations=df_1.groupby('Content Rating')['Installs'].sum().astype('int64')
content_apps_intallations.sort_values(ascending=False)

# Visulization

fig=plt.figure(figsize=(20,4))
plt.subplot(1, 2, 1)

# Total Apps according to Content Rating Count
plt.barh(content_rating_counts.index, content_rating_counts.values, color='skyblue')
plt.title("Content Ratings Distribution")
plt.xlabel("Number of Apps")
plt.ylabel("Content Rating")


#Total Installation According to Content Rating Wise
plt.subplot(1,2,2)
plt.barh(content_apps_intallations.index, content_apps_intallations.values, color='skyblue')
plt.title("Number of installation acc. to content")
plt.xlabel("Number of Apps")
plt.ylabel("Installation")
plt.show()

"""**Observation**

1.   Content Rating for everyone apps count is more.
2.   Everyone 10+ apps is less compare to mature17+ but installation wise everyone10+ apps install more than mature 17+ content rating

Q3) **Top apps Category count & top Category apps installs**
"""

#Top apps Category count
top10_catg= df_1['Category'].value_counts().sort_values(ascending=False).head(10)
top10_catg

# Top Category apps installs
catg_apps_ins=df_1.groupby('Category')['Installs'].sum().sort_values(ascending=False).astype('int64').head(10)
catg_apps_ins

# Visulization

fig=plt.figure(figsize=(15,4))
plt.subplot(1, 2, 1)
# Top Category apps count

top10_catg.plot(kind='pie', startangle=280, pctdistance=0.85,explode = (0.0, 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0),autopct='%1.1f%%')
plt.title(' Top Installation Category wise',fontsize=10,fontweight='bold')
plt.ylabel('')

centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()# for adding the circle
fig.gca().add_artist(centre_circle)
fig.patch.set_facecolor('#95a3a6')


plt.subplot(1, 2, 2)
# Top Category apps installs
catg_apps_ins.plot(kind='pie', startangle=160, pctdistance=0.85,explode = (0.0, 0.1,0.2,0.1,0.1,0.1,0.1,0.2,0.1,0.3),autopct='%1.1f%%')
plt.title(' Top Installation Category wise',fontsize=10,fontweight='bold')
plt.ylabel('')

centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)
fig.patch.set_facecolor('#95a3a6')

plt.show()

"""**Observation**

1)Number of apps more in Family Category & game is second highest.

2)Game installation app is 1st and Communication apps installation is second, Family apps installation is 6th.

Q4) **Top App install & Category wise top apps**
"""

#Top Apps Install
Top_app=df_1.groupby('App')['Installs'].sum().sort_values(ascending=False).head(10).astype('int64')
Top_app

# Top Apps category Wise

top_catagery_apps=df_1.groupby(['Category','App'])['Installs'].sum().sort_values(ascending=False).head(10).astype('int64')
top_catagery_apps

#Visulization

fig=plt.figure(figsize=(18,4))
plt.subplot(1, 2, 1)

#Top Apps Install
Top_app.plot(kind='pie', startangle=280, pctdistance=0.85,autopct='%1.1f%%')
plt.title('Top apps Install',fontsize=15,fontweight='bold')
plt.ylabel('')

centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)
fig.patch.set_facecolor('#95a3a6')

#Top Apps category Wise
plt.subplot(1, 2, 2)
top_catagery_apps.plot(kind='pie', startangle=280, pctdistance=0.85,autopct='%1.1f%%')
plt.title('Top Category apps Install',fontsize=15,fontweight='bold')
plt.ylabel('')

centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)
fig.patch.set_facecolor('#95a3a6')

plt.show()

"""**Observation**



1. Top 10 Installation 3 games apps. Subway Surfer, Candycrush Saga, Temple Run
2. In Top 10 Installation Category apps  2 Gaming Apps

1.  Games apps intallation is highest in Play store

Q5) **Top 20 rating count, Top20 Rated Category, Top 10 Rated Category Installation**
"""

# Top Ratings Apps
T_Rating=df_1['Rating'].value_counts().sort_values(ascending=False).head(20).reset_index()
T_Rating

# Top Rated Category

t_rating_category=df_1.groupby('Category')['Rating'].value_counts().sort_values(ascending=False).head(20)
t_rating_category

# Top Rated Catagory Apps Installations.
top_Rating_apps=df_1.groupby(['Category','Rating'])['Installs'].sum().sort_values(ascending=False).astype('int64').reset_index()
top_Rating_apps

# Visulization

plt.figure(figsize=(10,4))
sns.barplot(x='index',y='Rating',data=T_Rating)
plt.title("Content Ratings Distribution")
plt.xlabel('rating')
plt.ylabel('no. of apps')
plt.show()

plt.figure(figsize=(15,4))
sns.boxplot(data=top_Rating_apps, x='Category', y='Rating')
plt.title("Rating Distribution by Category")
plt.xticks(rotation=90)
plt.ylabel("Rating")
plt.show()

"""**Observation**


1.   Highest App rating is 5 and lowest in top 20 is 3.0
2.   Major apps got 4.3 Rating

3.   We already know by above observation Family category having more apps.So Family Apps having 4.6, 4.5, 4.3, 4.2.
4.  Games category got 2 ratings 4.4 & 4.3 ratings
5. Games category having highest rating apps intallation

   **Higher rating, more consumer intrested to download Perticular apps**

Q6)**App installation Rating & Installed app review**
"""

Total_review=df_1.groupby(['Category','App','Installs'])['Rating'].value_counts().sort_values(ascending=False).astype('int64').head(20)
Total_review.T

Total_review1=df_1.groupby(['Category','App','Installs'])['Reviews'].sum().sort_values(ascending=False).head(10)
Total_review1.T

# Co-relation btw install, review, Remark, price

#convert Review column object to Integer.
df_1['Reviews']=df_1['Reviews'].astype('int64')

# now find Co-relation
corr_rel=df_1[['Installs','Reviews','Rating','Price']].corr()
corr_rel

# Visulization
# CO-relation
plt.figure(figsize=(5,5))
sns.heatmap(corr_rel,annot=True, cmap='icefire')
plt.title("Correlation of Data",size='20');

"""**Observation**
>factor which affect the Installation of Apps is Review of App, Ratings of Apps.

Q7) **Which Apps having positive rating and review**
"""

sntmt=df_2.groupby('App')['Sentiment_Polarity'].sum().reset_index().sort_values(by='Sentiment_Polarity',ascending=False)
sntmt.head()

sntmt2=df_2.groupby('App')['Sentiment'].count().sort_values(ascending=False).head()
sntmt2=sntmt2.reset_index()
sntmt2

fig = plt.figure(figsize=(10,4))
plt.bar('App','Sentiment',data=sntmt2)
plt.xticks(rotation = 60)
plt.title("Top sentiment polarity Apps")
plt.show()

"""**Observation**

Facebook has less installation but more Sentiment polarity, its shows postve review given by Constumer
"""

df_2.columns

"""Q8) **total number of app sentiment count**"""

sentiment_count=df_2.groupby(['Sentiment'])['App'].count().sort_values(ascending=False)
sentiment_count= sentiment_count.reset_index()
sentiment_count

fig = plt.figure(figsize=(5,4))
sns.lineplot(x='Sentiment',y='App', data=sentiment_count, palette="Set2")
plt.title("Total app count sentiment wise")
plt.show()

"""Q9) **Relation of sentiment Polarity & SENTIMENT subjectivity**"""

# Visulization
plt.figure(figsize=(10, 5))

#df_2.plot(kind='scatter', x='Sentiment_Polarity', y='Sentiment_Subjectivity',c=colors)
sns.scatterplot(x="Sentiment_Polarity", y="Sentiment_Subjectivity", data=df_2, hue="Sentiment")
plt.title("Relation of sentiment Polarity & SENTIMENT subjectivity", fontsize=20)
plt.show()

df_2.head()

"""Histogram with the kde for the rating column for dataset1

Q10)Where are the most rated values distributed?
"""

sns.histplot(df_1["Rating"], kde = True)
plt.title("Histogram with the kde for the rating column ", size=20,)

"""Observation:
The most values are distributed around 4.3

# **Summary** and **Conclusion**

Most of the apps are free so developers should focus on creating free apps to have a huge customer base. If developing paid apps then apps size should not be greater than 40mb. More Apps should be in the category like Events,Beauty,Parenting as they have not been explored much but still quite popular with huge installations. In order to retain the customer base apps should be updated regularly Developers should develop apps such that their content is available for everyone. Bulky apps should be developed in the category like Game, Family. If developing paid apps then its price should not be high and size should be less than 20mb. Apps belonging to Game and Family Category have high negative reviews therefore they should be developed carefully. Like this there can be a lot of conclusions but we have tried to cover the most important ones. These are some of the aspects that the developer should research before proceeding with the app development. By conducting a simple exploratory data analysis (EDA) on the play store dataset, we not only eliminate avoidable risks of failure, but we may also be able to provide better ideas for building the app.

# Below are the observations from this project:

Total number of apps are 10346

Free app count :-9584, Paid app Count:-762

Out of Total apps in google play according to dataset 92.6% Apss are free &7.4% Apps are Paid

Total number of Installation in Free apps is more compare to Paid Apps In bar graph it is not visible because number of Paid app is less.

Content Rating for everyone apps count is more.
Everyone 10+ apps is less compare to mature17+ but installation wise everyone10+ apps install more than mature 17+ content rating.

Number of apps more in Family Category & game is second highest.

2)Game installation app is 1st and Communication apps installation is second, Family apps installation is 6th.

Top 10 Installation 3 games apps. Subway Surfer, Candycrush Saga, Temple Run

In Top 10 Installation Category apps 2 Gaming Apps

Games apps intallation is highest in Play store.

Highest App rating is 5 and lowest in top 20 is 3.0

Major apps got 4.3 Rating

Games category got 2 ratings 4.4 & 4.3 ratings

Games category having highest rating apps intallation

Higher rating, more consumer intrested to download Perticular apps.

Facebook has less installation but more Sentiment polarity, its shows postve review given by Constumer.

The most values are distributed around 4.3 and many more observations through this project analysis.
"""